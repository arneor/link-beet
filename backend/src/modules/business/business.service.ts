import {
    Injectable,
    NotFoundException,
    ForbiddenException,
    Logger
} from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model, Types } from 'mongoose';
import { BusinessProfile, BusinessProfileDocument, Ad } from './schemas/business-profile.schema';
import { AnalyticsLog, AnalyticsLogDocument } from '../analytics/schemas/analytics-log.schema';
import { ComplianceLog, ComplianceLogDocument } from '../compliance/schemas/compliance-log.schema';
import { CreateBusinessDto, UpdateBusinessDto, DashboardStatsDto } from './dto/business.dto';

import { S3Service } from '../media/s3.service';

@Injectable()
export class BusinessService {
    private readonly logger = new Logger(BusinessService.name);

    constructor(
        @InjectModel(BusinessProfile.name) private businessModel: Model<BusinessProfileDocument>,
        @InjectModel(AnalyticsLog.name) private analyticsModel: Model<AnalyticsLogDocument>,
        @InjectModel(ComplianceLog.name) private complianceModel: Model<ComplianceLogDocument>,
        private readonly s3Service: S3Service,
    ) { }

    async uploadMedia(
        businessId: string,
        file: Express.Multer.File,
        placement: string, // 'branding', 'banner', 'gallery'
        ownerId: string,
        isAdmin: boolean = false
    ) {
        // 1. Get Business & Verify Access
        const business = await this.findById(businessId);
        if (!isAdmin && business.ownerId.toString() !== ownerId) {
            throw new ForbiddenException('You do not have permission to upload media for this business');
        }

        // 2. Upload to S3
        const { url, key } = await this.s3Service.upload(file, 'business', businessId, placement);

        // 3. Update Database based on placement
        if (placement === 'branding') {
            // Cleanup old logo if exists
            if (business.logoS3Key) {
                await this.s3Service.delete(business.logoS3Key);
            }
            business.logoUrl = url;
            business.logoS3Key = key;
        } else if (placement === 'banner' || placement === 'gallery') {
            // Create new Ad
            // Map placement: 'banner' -> 'BANNER', 'gallery' -> 'GALLERY' (or use uppercase)
            const adPlacement = placement === 'banner' ? 'BANNER' : 'GALLERY';

            business.ads.push({
                mediaUrl: url,
                mediaType: file.mimetype.startsWith('video') ? 'video' : 'image',
                title: file.originalname,
                s3Key: key,
                placement: adPlacement,
                source: 'INTERNAL',
                status: 'active',
                duration: 5,
                views: 0,
                clicks: 0,
                createdAt: new Date(),
                // id is generated by Subdocument default
            } as any);
        }

        const savedBusiness = await business.save();
        this.logger.log(`Uploaded media for business ${businessId}: ${placement}`);

        return { url, key, business: savedBusiness };


    }

    /**
     * Create a new business profile (status: pending_approval by default)
     */
    async create(ownerId: string, dto: CreateBusinessDto): Promise<BusinessProfileDocument> {
        // Check for username uniqueness if provided
        if (dto.username) {
            const existing = await this.businessModel.findOne({ username: dto.username });
            if (existing) {
                throw new ForbiddenException('Username is already taken');
            }
        }

        const business = new this.businessModel({
            ...dto,
            ownerId: new Types.ObjectId(ownerId),
            status: 'pending_approval', // Default to pending approval
            isActive: false, // Not active until approved
            statusHistory: [{
                status: 'pending_approval',
                changedAt: new Date(),
            }],
        });

        await business.save();
        this.logger.log(`Created business: ${business.businessName} for owner: ${ownerId} (pending approval)`);
        return business;
    }

    /**
     * Get business by ID
     */
    async findById(id: string): Promise<BusinessProfileDocument> {
        const business = await this.businessModel.findById(id);

        if (!business) {
            throw new NotFoundException('Business not found');
        }

        return business;
    }

    /**
     * Get business by owner ID
     */
    async findByOwnerId(ownerId: string): Promise<BusinessProfileDocument | null> {
        return this.businessModel.findOne({ ownerId: new Types.ObjectId(ownerId) });
    }

    /**
     * Get business by username (public)
     */
    async findByUsername(username: string): Promise<BusinessProfileDocument> {
        const business = await this.businessModel.findOne({ username });

        if (!business) {
            throw new NotFoundException('Business not found');
        }

        return business;
    }

    /**
     * Update business profile
     */
    async update(
        id: string,
        ownerId: string,
        dto: UpdateBusinessDto,
        isAdmin: boolean = false
    ): Promise<BusinessProfileDocument> {
        const business = await this.businessModel.findById(id);

        if (!business) {
            throw new NotFoundException('Business not found');
        }

        // Check ownership (admins can bypass)
        if (!isAdmin && business.ownerId.toString() !== ownerId) {
            throw new ForbiddenException('You do not have permission to update this business');
        }

        // Handle S3 image deletion when ads are removed
        if (dto.ads) {
            const oldS3Keys = business.ads
                .map(ad => ad.s3Key)
                .filter((key): key is string => !!key);

            const newS3Keys = new Set(
                dto.ads
                    .map(ad => ad.s3Key)
                    .filter((key): key is string => !!key)
            );

            const keysToDelete = oldS3Keys.filter(key => !newS3Keys.has(key));

            if (keysToDelete.length > 0) {
                this.logger.log(`Deleting ${keysToDelete.length} orphaned S3 images for business ${id}`);
                // Delete in background
                Promise.allSettled(
                    keysToDelete.map(key => this.s3Service.delete(key))
                ).catch(err =>
                    this.logger.error(`Error deleting orphan S3 images: ${err.message}`)
                );
            }
        }

        // Prevent non-admins from changing status
        if (!isAdmin) {
            delete (dto as any).status;
            delete (dto as any).isActive;
        }

        Object.assign(business, dto);
        await business.save();

        this.logger.log(`Updated business: ${business.businessName}${isAdmin ? ' (by admin)' : ''}`);
        return business;
    }

    /**
     * Get all businesses (for admin)
     */
    async findAll(): Promise<BusinessProfileDocument[]> {
        return this.businessModel.find({ status: 'active' }).sort({ createdAt: -1 });
    }

    /**
     * Get dashboard statistics for a business
     */
    async getDashboardStats(
        businessId: string,
        ownerId: string,
        isAdmin: boolean = false
    ): Promise<DashboardStatsDto> {
        const business = await this.businessModel.findById(businessId);

        if (!business) {
            throw new NotFoundException('Business not found');
        }

        // Check ownership (admins can bypass)
        if (!isAdmin && business.ownerId.toString() !== ownerId) {
            throw new ForbiddenException('You do not have permission to view this dashboard');
        }

        const businessObjectId = new Types.ObjectId(businessId);

        // Get analytics data
        const [viewsResult, clicksResult, connectionsResult] = await Promise.all([
            this.analyticsModel.countDocuments({
                businessId: businessObjectId,
                interactionType: 'view'
            }),
            this.analyticsModel.countDocuments({
                businessId: businessObjectId,
                interactionType: 'click'
            }),
            this.complianceModel.countDocuments({
                businessId: businessObjectId
            }),
        ]);

        // Calculate ad stats from nested ads array
        const totalAdViews = business.ads.reduce((sum: number, ad: Ad) => sum + (ad.views || 0), 0);
        const totalAdClicks = business.ads.reduce((sum: number, ad: Ad) => sum + (ad.clicks || 0), 0);

        // Get connections history (last 7 days)
        const connectionsHistory = await this.getConnectionsHistory(businessObjectId);

        // Calculate CTR
        const ctr = totalAdViews > 0 ? (totalAdClicks / totalAdViews) * 100 : 0;

        return {
            totalConnections: connectionsResult,
            activeUsers: 0, // Real-time active users logic not yet implemented
            totalAdsServed: totalAdViews,
            totalViews: viewsResult || totalAdViews,
            totalClicks: clicksResult || totalAdClicks,
            ctr: Math.round(ctr * 100) / 100,
            revenue: 0, // Revenue feature not available
            connectionsHistory,
        };
    }

    /**
     * Get connections history for charts
     */
    private async getConnectionsHistory(
        businessId: Types.ObjectId
    ): Promise<Array<{ date: string; count: number }>> {
        const days = 7;
        const history: Array<{ date: string; count: number }> = [];
        const now = new Date();

        for (let i = days - 1; i >= 0; i--) {
            const startDate = new Date(now);
            startDate.setDate(now.getDate() - i);
            startDate.setHours(0, 0, 0, 0);

            const endDate = new Date(startDate);
            endDate.setHours(23, 59, 59, 999);

            const count = await this.complianceModel.countDocuments({
                businessId,
                loginTime: { $gte: startDate, $lte: endDate },
            });

            history.push({
                date: startDate.toISOString().split('T')[0],
                count: count,
            });
        }

        return history;
    }

    /**
     * Get splash page data (public endpoint) - only for active businesses
     */
    async getSplashData(businessId: string) {
        const business = await this.businessModel.findById(businessId);

        if (!business) {
            throw new NotFoundException('Business not found');
        }

        // Only show splash for active businesses
        if (business.status !== 'active') {
            throw new NotFoundException('This WiFi network is currently unavailable');
        }

        // Filter active ads only
        const activeAds = business.ads.filter((ad: Ad) => ad.status === 'active');

        return {
            business: {
                id: business._id,
                name: business.businessName,
                location: business.location,
                logoUrl: business.logoUrl,
                primaryColor: business.primaryColor,
                googleReviewUrl: business.googleReviewUrl,
                description: business.description,
                category: business.category,
                wifiSsid: business.wifiSsid,
                welcomeTitle: business.welcomeTitle,
                ctaButtonText: business.ctaButtonText || 'View Offers',
                ctaButtonUrl: business.ctaButtonUrl,
                showWelcomeBanner: business.showWelcomeBanner !== false, // Default true
            },
            ads: activeAds.map((ad: Ad) => ({
                id: ad.id,
                title: ad.title,
                description: ad.description,
                mediaUrl: ad.mediaUrl,
                mediaType: ad.mediaType,
                ctaUrl: ad.ctaUrl || business.googleReviewUrl,
                duration: ad.duration,
                placement: ad.placement,
                status: ad.status,
                likesCount: ad.likesCount || 0,
            })),
        };
    }

    /**
     * Get admin access logs for a business (for transparency)
     */
    async getAdminAccessLogs(businessId: string): Promise<any[]> {
        // Import AdminAccessLog model dynamically to avoid circular dependency
        try {
            const mongoose = require('mongoose');
            const AdminAccessLog = mongoose.model('AdminAccessLog');

            const logs = await AdminAccessLog.find({
                businessId: new Types.ObjectId(businessId)
            })
                .sort({ timestamp: -1 })
                .limit(50)
                .lean();

            return logs.map((log: any) => ({
                id: log._id.toString(),
                adminEmail: log.adminEmail,
                action: log.action,
                timestamp: log.timestamp,
                details: log.details,
            }));
        } catch (error) {
            this.logger.warn(`Could not fetch admin access logs: ${error.message}`);
            return [];
        }
    }
}
